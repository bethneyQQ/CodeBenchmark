"""
Continuous Vulnerability Scanning and Dependency Auditing System

Provides automated security scanning capabilities for the evaluation engine.
"""

import asyncio
import json
import subprocess
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, asdict
from pathlib import Path
import hashlib
import requests
from packaging import version
import yaml

logger = logging.getLogger(__name__)

@dataclass
class Vulnerability:
    """Represents a security vulnerability"""
    id: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    package: str
    version: str
    description: str
    cve_id: Optional[str] = None
    fixed_version: Optional[str] = None
    published_date: Optional[datetime] = None
    discovered_date: datetime = None
    
    def __post_init__(self):
        if self.discovered_date is None:
            self.discovered_date = datetime.utcnow()

@dataclass
class ScanResult:
    """Results from a vulnerability scan"""
    scan_id: str
    timestamp: datetime
    vulnerabilities: List[Vulnerability]
    total_packages: int
    vulnerable_packages: int
    scan_duration: float
    scan_type: str
    
    @property
    def critical_count(self) -> int:
        return len([v for v in self.vulnerabilities if v.severity == 'CRITICAL'])
    
    @property
    def high_count(self) -> int:
        return len([v for v in self.vulnerabilities if v.severity == 'HIGH'])
    
    @property
    def medium_count(self) -> int:
        return len([v for v in self.vulnerabilities if v.severity == 'MEDIUM'])
    
    @property
    def low_count(self) -> int:
        return len([v for v in self.vulnerabilities if v.severity == 'LOW'])

class VulnerabilityDatabase:
    """Manages vulnerability database and updates"""
    
    def __init__(self, db_path: str = "security/vuln_db.json"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.last_update: Optional[datetime] = None
        self._load_database()
    
    def _load_database(self):
        """Load vulnerability database from disk"""
        if self.db_path.exists():
            try:
                with open(self.db_path, 'r') as f:
                    data = json.load(f)
                    self.vulnerabilities = {
                        k: Vulnerability(**v) for k, v in data.get('vulnerabilities', {}).items()
                    }
                    if data.get('last_update'):
                        self.last_update = datetime.fromisoformat(data['last_update'])
            except Exception as e:
                logger.error(f"Failed to load vulnerability database: {e}")
    
    def _save_database(self):
        """Save vulnerability database to disk"""
        try:
            data = {
                'vulnerabilities': {k: asdict(v) for k, v in self.vulnerabilities.items()},
                'last_update': self.last_update.isoformat() if self.last_update else None
            }
            with open(self.db_path, 'w') as f:
                json.dump(data, f, indent=2, default=str)
        except Exception as e:
            logger.error(f"Failed to save vulnerability database: {e}")
    
    async def update_database(self) -> bool:
        """Update vulnerability database from external sources"""
        try:
            # Update from multiple sources
            await self._update_from_osv()
            await self._update_from_nvd()
            
            self.last_update = datetime.utcnow()
            self._save_database()
            logger.info("Vulnerability database updated successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to update vulnerability database: {e}")
            return False
    
    async def _update_from_osv(self):
        """Update from OSV (Open Source Vulnerabilities) database"""
        # Implementation would fetch from OSV API
        # For now, we'll simulate with known vulnerabilities
        pass
    
    async def _update_from_nvd(self):
        """Update from NVD (National Vulnerability Database)"""
        # Implementation would fetch from NVD API
        # For now, we'll simulate with known vulnerabilities
        pass

class VulnerabilityScanner:
    """Continuous vulnerability scanning and dependency auditing system"""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.scan_interval = self.config.get('scan_interval', 3600)  # 1 hour
        self.auto_update_db = self.config.get('auto_update_db', True)
        self.severity_threshold = self.config.get('severity_threshold', 'MEDIUM')
        
        self.vuln_db = VulnerabilityDatabase()
        self.scan_history: List[ScanResult] = []
        self.is_scanning = False
        self._scan_task: Optional[asyncio.Task] = None
    
    async def start_continuous_scanning(self):
        """Start continuous vulnerability scanning"""
        if self._scan_task and not self._scan_task.done():
            logger.warning("Continuous scanning already running")
            return
        
        self._scan_task = asyncio.create_task(self._continuous_scan_loop())
        logger.info("Started continuous vulnerability scanning")
    
    async def stop_continuous_scanning(self):
        """Stop continuous vulnerability scanning"""
        if self._scan_task:
            self._scan_task.cancel()
            try:
                await self._scan_task
            except asyncio.CancelledError:
                pass
        logger.info("Stopped continuous vulnerability scanning")
    
    async def _continuous_scan_loop(self):
        """Main loop for continuous scanning"""
        while True:
            try:
                # Update vulnerability database if needed
                if self.auto_update_db:
                    if (not self.vuln_db.last_update or 
                        datetime.utcnow() - self.vuln_db.last_update > timedelta(hours=24)):
                        await self.vuln_db.update_database()
                
                # Perform scan
                scan_result = await self.scan_dependencies()
                
                # Process results
                await self._process_scan_results(scan_result)
                
                # Wait for next scan
                await asyncio.sleep(self.scan_interval)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in continuous scan loop: {e}")
                await asyncio.sleep(60)  # Wait 1 minute before retrying
    
    async def scan_dependencies(self) -> ScanResult:
        """Scan project dependencies for vulnerabilities"""
        if self.is_scanning:
            raise RuntimeError("Scan already in progress")
        
        self.is_scanning = True
        start_time = datetime.utcnow()
        scan_id = hashlib.md5(f"{start_time.isoformat()}".encode()).hexdigest()[:8]
        
        try:
            vulnerabilities = []
            total_packages = 0
            vulnerable_packages = 0
            
            # Scan Python dependencies
            python_vulns, python_total, python_vulnerable = await self._scan_python_dependencies()
            vulnerabilities.extend(python_vulns)
            total_packages += python_total
            vulnerable_packages += python_vulnerable
            
            # Scan Node.js dependencies (if applicable)
            node_vulns, node_total, node_vulnerable = await self._scan_node_dependencies()
            vulnerabilities.extend(node_vulns)
            total_packages += node_total
            vulnerable_packages += node_vulnerable
            
            # Scan Docker images
            docker_vulns, docker_total, docker_vulnerable = await self._scan_docker_images()
            vulnerabilities.extend(docker_vulns)
            total_packages += docker_total
            vulnerable_packages += docker_vulnerable
            
            end_time = datetime.utcnow()
            scan_duration = (end_time - start_time).total_seconds()
            
            scan_result = ScanResult(
                scan_id=scan_id,
                timestamp=start_time,
                vulnerabilities=vulnerabilities,
                total_packages=total_packages,
                vulnerable_packages=vulnerable_packages,
                scan_duration=scan_duration,
                scan_type="full"
            )
            
            self.scan_history.append(scan_result)
            logger.info(f"Vulnerability scan completed: {len(vulnerabilities)} vulnerabilities found")
            
            return scan_result
            
        finally:
            self.is_scanning = False
    
    async def _scan_python_dependencies(self) -> tuple[List[Vulnerability], int, int]:
        """Scan Python dependencies using safety and pip-audit"""
        vulnerabilities = []
        total_packages = 0
        vulnerable_packages = 0
        
        try:
            # Use pip-audit for comprehensive scanning
            result = subprocess.run([
                'pip-audit', '--format=json', '--desc'
            ], capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                data = json.loads(result.stdout)
                for vuln_data in data.get('vulnerabilities', []):
                    vulnerability = Vulnerability(
                        id=f"pip-{vuln_data.get('id', 'unknown')}",
                        severity=self._map_severity(vuln_data.get('severity', 'UNKNOWN')),
                        package=vuln_data.get('package', 'unknown'),
                        version=vuln_data.get('installed_version', 'unknown'),
                        description=vuln_data.get('description', ''),
                        cve_id=vuln_data.get('cve_id'),
                        fixed_version=vuln_data.get('fixed_version')
                    )
                    vulnerabilities.append(vulnerability)
                
                total_packages = len(data.get('packages', []))
                vulnerable_packages = len(set(v.package for v in vulnerabilities))
            
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, json.JSONDecodeError) as e:
            logger.warning(f"Failed to scan Python dependencies: {e}")
        
        return vulnerabilities, total_packages, vulnerable_packages
    
    async def _scan_node_dependencies(self) -> tuple[List[Vulnerability], int, int]:
        """Scan Node.js dependencies using npm audit"""
        vulnerabilities = []
        total_packages = 0
        vulnerable_packages = 0
        
        if not Path('package.json').exists():
            return vulnerabilities, total_packages, vulnerable_packages
        
        try:
            result = subprocess.run([
                'npm', 'audit', '--json'
            ], capture_output=True, text=True, timeout=300)
            
            if result.stdout:
                data = json.loads(result.stdout)
                for vuln_id, vuln_data in data.get('vulnerabilities', {}).items():
                    vulnerability = Vulnerability(
                        id=f"npm-{vuln_id}",
                        severity=vuln_data.get('severity', 'UNKNOWN').upper(),
                        package=vuln_data.get('name', 'unknown'),
                        version=vuln_data.get('version', 'unknown'),
                        description=vuln_data.get('title', ''),
                        cve_id=vuln_data.get('cve')
                    )
                    vulnerabilities.append(vulnerability)
                
                total_packages = len(data.get('metadata', {}).get('dependencies', {}))
                vulnerable_packages = len(vulnerabilities)
            
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, json.JSONDecodeError) as e:
            logger.warning(f"Failed to scan Node.js dependencies: {e}")
        
        return vulnerabilities, total_packages, vulnerable_packages
    
    async def _scan_docker_images(self) -> tuple[List[Vulnerability], int, int]:
        """Scan Docker images using trivy"""
        vulnerabilities = []
        total_packages = 0
        vulnerable_packages = 0
        
        try:
            # Scan Dockerfile if it exists
            if Path('Dockerfile').exists():
                result = subprocess.run([
                    'trivy', 'config', '--format', 'json', 'Dockerfile'
                ], capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0 and result.stdout:
                    data = json.loads(result.stdout)
                    for result_data in data.get('Results', []):
                        for vuln in result_data.get('Vulnerabilities', []):
                            vulnerability = Vulnerability(
                                id=f"docker-{vuln.get('VulnerabilityID', 'unknown')}",
                                severity=vuln.get('Severity', 'UNKNOWN'),
                                package=vuln.get('PkgName', 'unknown'),
                                version=vuln.get('InstalledVersion', 'unknown'),
                                description=vuln.get('Description', ''),
                                cve_id=vuln.get('VulnerabilityID'),
                                fixed_version=vuln.get('FixedVersion')
                            )
                            vulnerabilities.append(vulnerability)
                    
                    total_packages = len(set(v.package for v in vulnerabilities))
                    vulnerable_packages = len(vulnerabilities)
            
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, json.JSONDecodeError) as e:
            logger.warning(f"Failed to scan Docker images: {e}")
        
        return vulnerabilities, total_packages, vulnerable_packages
    
    def _map_severity(self, severity: str) -> str:
        """Map various severity formats to standard levels"""
        severity = severity.upper()
        mapping = {
            'CRITICAL': 'CRITICAL',
            'HIGH': 'HIGH', 
            'MODERATE': 'MEDIUM',
            'MEDIUM': 'MEDIUM',
            'LOW': 'LOW',
            'INFO': 'LOW',
            'INFORMATIONAL': 'LOW'
        }
        return mapping.get(severity, 'MEDIUM')
    
    async def _process_scan_results(self, scan_result: ScanResult):
        """Process scan results and trigger alerts if needed"""
        # Filter by severity threshold
        critical_vulns = [v for v in scan_result.vulnerabilities 
                         if v.severity in ['CRITICAL', 'HIGH']]
        
        if critical_vulns:
            await self._trigger_security_alert(scan_result, critical_vulns)
        
        # Log scan summary
        logger.info(f"Scan {scan_result.scan_id} completed: "
                   f"{scan_result.critical_count} critical, "
                   f"{scan_result.high_count} high, "
                   f"{scan_result.medium_count} medium, "
                   f"{scan_result.low_count} low vulnerabilities")
    
    async def _trigger_security_alert(self, scan_result: ScanResult, 
                                    critical_vulns: List[Vulnerability]):
        """Trigger security alert for critical vulnerabilities"""
        alert_data = {
            'scan_id': scan_result.scan_id,
            'timestamp': scan_result.timestamp.isoformat(),
            'critical_vulnerabilities': [asdict(v) for v in critical_vulns],
            'total_vulnerabilities': len(scan_result.vulnerabilities)
        }
        
        # This would integrate with the incident detection system
        logger.critical(f"SECURITY ALERT: {len(critical_vulns)} critical vulnerabilities found")
        
        # Save alert to file for incident detector to pick up
        alert_file = Path("security/alerts") / f"vuln_alert_{scan_result.scan_id}.json"
        alert_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(alert_file, 'w') as f:
            json.dump(alert_data, f, indent=2, default=str)
    
    def get_scan_history(self, limit: Optional[int] = None) -> List[ScanResult]:
        """Get scan history"""
        history = sorted(self.scan_history, key=lambda x: x.timestamp, reverse=True)
        return history[:limit] if limit else history
    
    def get_vulnerability_summary(self) -> Dict[str, Any]:
        """Get summary of current vulnerabilities"""
        if not self.scan_history:
            return {'status': 'no_scans', 'message': 'No scans performed yet'}
        
        latest_scan = self.scan_history[-1]
        return {
            'status': 'scanned',
            'last_scan': latest_scan.timestamp.isoformat(),
            'total_vulnerabilities': len(latest_scan.vulnerabilities),
            'critical': latest_scan.critical_count,
            'high': latest_scan.high_count,
            'medium': latest_scan.medium_count,
            'low': latest_scan.low_count,
            'vulnerable_packages': latest_scan.vulnerable_packages,
            'total_packages': latest_scan.total_packages
        }