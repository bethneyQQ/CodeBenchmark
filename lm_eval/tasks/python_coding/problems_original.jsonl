{"category": "code_completion", "context": "Google Python Style Guide: Use descriptive variable names, add type hints, include docstrings for all functions. Maximum line length 80 characters. Use snake_case for variables and functions.", "context_type": "style_guide", "incomplete_code": "def calculate_fibonacci(n):\n    if n <= 1:\n        return n\n    # Complete the recursive implementation", "expected_completion": "return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)"}

{"category": "code_completion", "context": "Enterprise Security Policy: All user inputs must be validated. Use parameterized queries for database operations. Implement proper error handling with logging. No hardcoded credentials or sensitive data.", "context_type": "security_policy", "incomplete_code": "class BinaryTree:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n    \n    def insert(self, value):\n        # Complete the insertion logic", "expected_completion": "if value < self.value:\n            if self.left is None:\n                self.left = BinaryTree(value)\n            else:\n                self.left.insert(value)\n        else:\n            if self.right is None:\n                self.right = BinaryTree(value)\n            else:\n                self.right.insert(value)"}

{"category": "code_completion", "context": "Performance Requirements: Code must handle 10M+ records efficiently. Use list comprehensions and generator expressions where possible. Avoid nested loops. Memory usage should not exceed 1GB for large datasets.", "context_type": "performance_requirements", "incomplete_code": "def filter_even_squares(numbers):\n    # Complete using list comprehension to return squares of even numbers", "expected_completion": "return [x**2 for x in numbers if x % 2 == 0]"}

{"category": "code_completion", "context": "Production Reliability Standards: All functions must handle edge cases gracefully. Use try-except blocks for external operations. Return None or appropriate default values for error cases. Log all exceptions with context.", "context_type": "reliability_standards", "incomplete_code": "def safe_divide(a, b):\n    # Complete with proper error handling", "expected_completion": "try:\n        return a / b\n    except ZeroDivisionError:\n        return None"}

{"category": "code_completion", "context": "DevOps Best Practices: Use context managers for resource management. Implement proper file handling with automatic cleanup. Include progress indicators for long-running operations. Support both sync and async operations.", "context_type": "devops_practices", "incomplete_code": "def read_file_lines(filename):\n    # Complete using context manager", "expected_completion": "with open(filename, 'r') as f:\n        return f.readlines()"}

{"category": "code_repair", "context": "Code Review Standards: Fix all syntax errors and logic bugs. Ensure functions handle empty inputs correctly. Add input validation where missing. Follow defensive programming principles.", "context_type": "code_review", "buggy_code": "def find_max(numbers):\n    max_num = 0\n    for num in numbers:\n        if num > max_num\n            max_num = num\n    return max_num", "error_description": "SyntaxError: missing colon and logic error with initialization", "fixed_code": "def find_max(numbers):\n    if not numbers:\n        return None\n    max_num = numbers[0]\n    for num in numbers:\n        if num > max_num:\n            max_num = num\n    return max_num", "test_cases": ["assert find_max([1, 3, 2]) == 3", "assert find_max([-1, -3, -2]) == -1", "assert find_max([]) is None"]}

{"category": "code_repair", "context": "Financial Services Compliance: All array/string operations must include bounds checking. Handle off-by-one errors carefully. Include comprehensive unit tests. Document all edge cases and assumptions.", "context_type": "financial_compliance", "buggy_code": "def reverse_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        result += s[len(s) - i]\n    return result", "error_description": "IndexError: string index out of range", "fixed_code": "def reverse_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        result += s[len(s) - 1 - i]\n    return result", "test_cases": ["assert reverse_string('hello') == 'olleh'", "assert reverse_string('') == ''", "assert reverse_string('a') == 'a'"]}

{"category": "code_repair", "context": "API Design Guidelines: All functions should handle missing keys gracefully. Use .get() method for dictionary access. Implement proper fallback mechanisms. Return consistent data types.", "context_type": "api_guidelines", "buggy_code": "def get_dict_value(d, key):\n    return d[key]", "error_description": "KeyError when key doesn't exist", "fixed_code": "def get_dict_value(d, key):\n    return d.get(key)", "test_cases": ["assert get_dict_value({'a': 1}, 'a') == 1", "assert get_dict_value({'a': 1}, 'b') is None", "assert get_dict_value({}, 'x') is None"]}

{"category": "code_repair", "context": "System Performance Policy: Avoid infinite loops at all costs. Include loop counters and exit conditions. Use proper increment/decrement operators. Monitor CPU usage in production code.", "context_type": "performance_policy", "buggy_code": "def count_down(n):\n    while n > 0:\n        print(n)\n        n + 1", "error_description": "Infinite loop - n never decreases", "fixed_code": "def count_down(n):\n    while n > 0:\n        print(n)\n        n -= 1", "test_cases": ["# Manual test: count_down(3) should print 3, 2, 1"]}

{"category": "code_repair", "context": "Data Processing Standards: Never modify collections during iteration. Use list comprehensions or filter() for safe operations. Create new collections instead of modifying existing ones. Handle concurrent access scenarios.", "context_type": "data_processing", "buggy_code": "def remove_negatives(numbers):\n    for num in numbers:\n        if num < 0:\n            numbers.remove(num)\n    return numbers", "error_description": "Skips elements when modifying list during iteration", "fixed_code": "def remove_negatives(numbers):\n    return [num for num in numbers if num >= 0]", "test_cases": ["assert remove_negatives([1, -2, 3, -4, 5]) == [1, 3, 5]", "assert remove_negatives([]) == []", "assert remove_negatives([1, 2, 3]) == [1, 2, 3]"]}

{"category": "code_translation", "context": "Cross-Platform Compatibility: Ensure translated code works on Python 3.8+. Use standard library functions where possible. Maintain exact functional equivalence. Include proper error handling for edge cases.", "context_type": "compatibility_requirements", "source_language": "javascript", "source_code": "function factorial(n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}", "target_code": "def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)"}

{"category": "code_translation", "context": "Enterprise Architecture Standards: Use static methods for utility functions. Follow object-oriented design patterns. Implement proper class hierarchies. Include type annotations and comprehensive docstrings.", "context_type": "architecture_standards", "source_language": "java", "source_code": "public class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n    \n    public static int multiply(int a, int b) {\n        return a * b;\n    }\n}", "target_code": "class Calculator:\n    @staticmethod\n    def add(a, b):\n        return a + b\n    \n    @staticmethod\n    def multiply(a, b):\n        return a * b"}

{"category": "code_translation", "context": "Pythonic Code Standards: Leverage Python's built-in functions and idioms. Avoid C-style loops when Python alternatives exist. Use sorted(), enumerate(), zip() where appropriate. Follow PEP 8 naming conventions.", "context_type": "pythonic_standards", "source_language": "c++", "source_code": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> sortVector(std::vector<int> vec) {\n    std::sort(vec.begin(), vec.end());\n    return vec;\n}", "target_code": "def sort_vector(vec):\n    return sorted(vec)"}

{"category": "code_translation", "context": "Error Handling Policy: Preserve all error handling logic from source language. Use appropriate Python exception types. Include proper exception chaining. Log errors with sufficient context for debugging.", "context_type": "error_handling_policy", "source_language": "javascript", "source_code": "function safeParse(jsonString) {\n    try {\n        return JSON.parse(jsonString);\n    } catch (error) {\n        return null;\n    }\n}", "target_code": "import json\n\ndef safe_parse(json_string):\n    try:\n        return json.loads(json_string)\n    except json.JSONDecodeError:\n        return None"}

{"category": "code_translation", "context": "Algorithm Optimization Guidelines: Replace manual loops with Python built-ins when possible. Use 'in' operator for membership testing. Leverage set operations for efficiency. Prefer generator expressions for memory efficiency.", "context_type": "optimization_guidelines", "source_language": "java", "source_code": "public static boolean containsElement(int[] array, int target) {\n    for (int element : array) {\n        if (element == target) {\n            return true;\n        }\n    }\n    return false;\n}", "target_code": "def contains_element(array, target):\n    return target in array"}

{"category": "docstring_generation", "context": "Google Documentation Standards: Use Google-style docstrings with Args, Returns, and Examples sections. Include type information in descriptions. Provide realistic usage examples. Document time/space complexity for algorithms.", "context_type": "documentation_standards", "function_code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "expected_docstring": "\"\"\"Performs binary search on a sorted array.\n\n    Args:\n        arr (list): A sorted list of comparable elements.\n        target: The element to search for.\n\n    Returns:\n        int: The index of the target element if found, -1 otherwise.\n\n    Example:\n        >>> binary_search([1, 2, 3, 4, 5], 3)\n        2\n        >>> binary_search([1, 2, 3, 4, 5], 6)\n        -1\n    \"\"\""}

{"category": "docstring_generation", "context": "Financial API Documentation: Include detailed parameter descriptions with units and ranges. Document all mathematical formulas used. Provide examples with real-world financial scenarios. Include references to financial standards.", "context_type": "financial_documentation", "function_code": "def calculate_compound_interest(principal, rate, time, compound_frequency=1):\n    return principal * (1 + rate / compound_frequency) ** (compound_frequency * time)", "expected_docstring": "\"\"\"Calculates compound interest.\n\n    Args:\n        principal (float): The initial amount of money.\n        rate (float): The annual interest rate as a decimal.\n        time (float): The time period in years.\n        compound_frequency (int, optional): Number of times interest is compounded per year. Defaults to 1.\n\n    Returns:\n        float: The final amount after compound interest.\n\n    Example:\n        >>> calculate_compound_interest(1000, 0.05, 2)\n        1102.5\n    \"\"\""}

{"category": "docstring_generation", "context": "Data Engineering Documentation: Document data transformation behavior clearly. Include information about data types and structures. Specify handling of duplicate keys and merge conflicts. Provide examples with realistic data.", "context_type": "data_engineering_docs", "function_code": "def merge_dictionaries(*dicts):\n    result = {}\n    for d in dicts:\n        result.update(d)\n    return result", "expected_docstring": "\"\"\"Merges multiple dictionaries into one.\n\n    Args:\n        *dicts (dict): Variable number of dictionaries to merge.\n\n    Returns:\n        dict: A new dictionary containing all key-value pairs from input dictionaries.\n              Later dictionaries override earlier ones for duplicate keys.\n\n    Example:\n        >>> merge_dictionaries({'a': 1}, {'b': 2}, {'a': 3})\n        {'a': 3, 'b': 2}\n    \"\"\""}

{"category": "docstring_generation", "context": "Security Documentation Requirements: Document all exceptions that can be raised. Include security considerations and input validation requirements. Specify expected input formats and validation rules. Include examples of both valid and invalid inputs.", "context_type": "security_documentation", "function_code": "def validate_email(email):\n    import re\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    if not re.match(pattern, email):\n        raise ValueError(\"Invalid email format\")\n    return True", "expected_docstring": "\"\"\"Validates an email address format.\n\n    Args:\n        email (str): The email address to validate.\n\n    Returns:\n        bool: True if the email format is valid.\n\n    Raises:\n        ValueError: If the email format is invalid.\n\n    Example:\n        >>> validate_email('user@example.com')\n        True\n        >>> validate_email('invalid-email')\n        ValueError: Invalid email format\n    \"\"\""}

{"category": "docstring_generation", "context": "Algorithm Documentation Standards: Include detailed complexity analysis (time and space). Document algorithm approach and key optimizations. Reference academic sources where applicable. Include performance characteristics and trade-offs.", "context_type": "algorithm_documentation", "function_code": "def quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)", "expected_docstring": "\"\"\"Sorts an array using the quicksort algorithm.\n\n    Args:\n        arr (list): The list to be sorted.\n\n    Returns:\n        list: A new sorted list.\n\n    Time Complexity:\n        Average case: O(n log n)\n        Worst case: O(nÂ²)\n\n    Space Complexity:\n        O(log n) due to recursion stack\n\n    Example:\n        >>> quicksort([3, 1, 4, 1, 5, 9, 2, 6])\n        [1, 1, 2, 3, 4, 5, 6, 9]\n    \"\"\""}

{"category": "function_generation", "context": "High-Performance Computing Requirements: Implement using dynamic programming for O(mn) time complexity. Use memoization to avoid redundant calculations. Handle Unicode strings correctly. Optimize for both time and space efficiency.", "context_type": "hpc_requirements", "function_description": "Create a function that finds the longest common subsequence between two strings", "requirements": "- Function name: longest_common_subsequence\n- Parameters: str1, str2\n- Return: string representing the LCS\n- Handle empty strings", "test_cases": ["assert longest_common_subsequence('ABCDGH', 'AEDFHR') == 'ADH'", "assert longest_common_subsequence('AGGTAB', 'GXTXAYB') == 'GTAB'", "assert longest_common_subsequence('', 'ABC') == ''", "assert longest_common_subsequence('ABC', '') == ''"]}

{"category": "function_generation", "context": "Distributed Systems Architecture: Implement thread-safe operations using appropriate locking mechanisms. Use OrderedDict for O(1) operations. Handle concurrent access patterns. Include proper cleanup and resource management.", "context_type": "distributed_systems", "function_description": "Create a function that implements a simple cache with LRU eviction policy", "requirements": "- Class name: LRUCache\n- Methods: __init__(capacity), get(key), put(key, value)\n- Capacity limit with LRU eviction\n- O(1) time complexity for both operations", "test_cases": ["cache = LRUCache(2)", "cache.put(1, 1)", "cache.put(2, 2)", "assert cache.get(1) == 1", "cache.put(3, 3)", "assert cache.get(2) == -1", "assert cache.get(3) == 3"]}

{"category": "function_generation", "context": "Telecommunications Industry Standards: Support international phone number formats (E.164). Handle country codes, area codes, and extensions. Implement comprehensive input validation. Return structured data for downstream processing.", "context_type": "telecom_standards", "function_description": "Create a function that validates and parses a phone number", "requirements": "- Function name: parse_phone_number\n- Parameter: phone_string\n- Return: dict with country_code, area_code, number\n- Support formats: +1-555-123-4567, (555) 123-4567, 555.123.4567\n- Return None for invalid formats", "test_cases": ["assert parse_phone_number('+1-555-123-4567') == {'country_code': '1', 'area_code': '555', 'number': '123-4567'}", "assert parse_phone_number('(555) 123-4567') == {'country_code': None, 'area_code': '555', 'number': '123-4567'}", "assert parse_phone_number('invalid') is None"]}

{"category": "function_generation", "context": "Cryptographic Performance Requirements: Use bit manipulation for maximum efficiency. Implement wheel factorization optimization. Handle large numbers (up to 10^9). Use numpy arrays for better performance with large datasets.", "context_type": "crypto_performance", "function_description": "Create a function that finds all prime numbers up to n using the Sieve of Eratosthenes", "requirements": "- Function name: sieve_of_eratosthenes\n- Parameter: n (integer)\n- Return: list of prime numbers\n- Use efficient sieve algorithm\n- Handle n <= 1", "test_cases": ["assert sieve_of_eratosthenes(10) == [2, 3, 5, 7]", "assert sieve_of_eratosthenes(2) == [2]", "assert sieve_of_eratosthenes(1) == []", "assert sieve_of_eratosthenes(30)[:6] == [2, 3, 5, 7, 11, 13]"]}

{"category": "function_generation", "context": "Search Engine Architecture: Implement memory-efficient trie structure. Use compressed nodes for space optimization. Support prefix matching with wildcards. Include serialization for persistent storage.", "context_type": "search_architecture", "function_description": "Create a function that implements a trie (prefix tree) for word storage and search", "requirements": "- Class name: Trie\n- Methods: __init__(), insert(word), search(word), starts_with(prefix)\n- Efficient prefix matching\n- Case-sensitive", "test_cases": ["trie = Trie()", "trie.insert('apple')", "assert trie.search('apple') == True", "assert trie.search('app') == False", "assert trie.starts_with('app') == True", "trie.insert('app')", "assert trie.search('app') == True"]}